(use-package :interval-tables)
	
(defun gen-random-table (max lap n)
  (declare (type (integer 1 100000000) max n)
	   (type (integer 1 1000000) lap))
  (let ((result (make-interval-table #'<)))
    (dotimes (i n result)
      (let ((lo (1+ (random max)))
	    (size (random lap)))
	(setf (get-interval lo (+ lo size) result) lo)))))

(defparameter *data-size* 10000)

(defun bench ()
  (let (table keys)
    (princ "Create:")
    (org.shirakumo.trivial-benchmark:with-timing (100)
      (setf table (gen-random-table *data-size* 20 *data-size*)))
    (format t "Actual table size: ~D~%" (interval-table-count table))
    (setf keys (map-intervals 'vector #'(lambda (lo hi val) (cons lo hi)) table))
    (princ "Count:")
    (org.shirakumo.trivial-benchmark:with-timing (1000)
      (interval-table-count table))
    (princ "get-min:")
    (org.shirakumo.trivial-benchmark:with-timing (10000)
      (get-min table))
    (princ "get-interval:")
    (org.shirakumo.trivial-benchmark:with-timing (100)
      (loop for iv across keys do
	    (get-interval (car iv) (cdr iv) table)))
    (princ "containing:")
    (org.shirakumo.trivial-benchmark:with-timing (100)
      (let ((total 0))
	(dotimes (i *data-size*)
	  (map-intervals nil #'(lambda (lo hi val) (incf total)) table :containing i))))
    ))
